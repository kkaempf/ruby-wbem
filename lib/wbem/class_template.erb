<%
  # @classes[name] = { :path => mofpath, :mof => mofclass }

  def collect_superclasses name
    classdata = @classmap[name]
    raise "No such class: #{name}" unless classdata
    mofclass = classdata[:mof]
    superclass = mofclass.superclass
    [mofclass] + ((superclass)?collect_superclasses(superclass):[])
  end
%>

# Class information for <%= name %>
# Generated by 'wbem' for use with ruby-wbem

require 'rubygems'
require 'cim'
require 'wbem'

module Wbem

  class <%= name %> < Wbem::Instance
<% classes = collect_superclasses name %>
<% known_features = Hash.new %>
    TYPEMAP = {
<%    classes.each do |mofclass|
        mofclass.features.each do |f|
          next if known_features[f.name]
          known_features[f.name] = f
          if f.method? %>
        # <%= mofclass.name %>.<%= f.name %>()
        <%= f.name.inspect %> => [ <%= f.type.to_sym.inspect %>, <% f.parameters.each do |p| %>
            [ <%= p.name.inspect %>, <%= p.type.to_sym.inspect %>, <%= (p.includes?(:out))?":out":":in" %> ], <% end %>
          ],
        <% else %>
        # <%= mofclass.name %>.<%= f.name %>
        <%= f.name.inspect %> => <%= f.type.to_sym.inspect %>,
<%        end
        end
      end %>
    }
    
    def _typemap
      TYPEMAP
    end

    #
    # Class constructor
    #   client - client instance, used for method invocation
    #            either a Wbem::CimxmlClient
    #            or a Wbem::WsmanClient
    #
    #   instance_ref - instance reference
    #                  either ObjectPath (Wbem::CimxmlClient) or
    #                  EndPointReference (Wbem::WsmanClient)
    #
    #   instance_data - instance data
    #                   Wbem::WsmanClient: Openwsman::XmlNode
    #                   Wbem::CimxmlClient: nil (instance_ref has all information)
    #
    def initialize client, instance_ref, instance_data = nil
      super
    end
    #
    # method_missing
    #   needs to be here to access TYPEMAP
    #
    def method_missing name, *args
      # http://stackoverflow.com/questions/8960685/ruby-why-does-puts-call-to-ary
      raise NoMethodError if name == :to_ary
      name = name.to_s
      assign = false
      if name[-1,1] == '=' # assignment
        name = name[0...-1]
        assign = true
      end
      type = TYPEMAP[name]
      if type.is_a? Array
        invoke(name, type, args)
      else
        return nil unless type # unknown property
        if assign
          # property assignment
          self[name] = Wbem::Conversion.from_ruby type, args[0]
        else
          # property read
          value = self[name]
          Wbem::Conversion.to_ruby type, value
        end
      end
    end # method_missing
  end # class
end # module
